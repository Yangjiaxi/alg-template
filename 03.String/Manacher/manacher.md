# Manacher最长回文子串

线性时间寻找最长回文子串。

思想：

- 维护「目前找到的最长回文子串的边界」
- 对于一个新的位置
  - 如果在边界内，利用对称性，将对侧位置的回文长度直接赋值(A.)
    - 如果对侧位置的回文长度给到当前位置后超出了右边界，则要截断，因为无法保证超出的部分也是满足回文的(B.)
  - 如果不在边界内，利用朴素思想，向两侧推进(C.)
- 如果向外推进了，则要维护回文子串的边界坐标

e.g.

输入`abababc`，变为`#a#b#a#b#a#b#c#`

- `i` 该算法为线性扫描算法，`i`指当前处理的元素
- `S[i]` 处理后的字符串的第`i`个字符
- `<l, r>` 当前的最远边界
- `k` 本循环中的回文半径
- `D[i]` 以第`i`个字符为中心的回文半径

|  `i` | `S[i]` |  `l`  |  `r`  | `k\<FINAL\>` | `D[i]` | palindrome  |
| ---: | :----: | :---: | :---: | :----------: | :----: | :---------: |
|    0 |   #    |   0   |   0   |      0       |   1    |      #      |
|    1 |   a    |   0   |   2   |      1       |   2    |     #a#     |
|    2 |   #    |   0   |   2   |      0       |   1    |      #      |
|    3 |   b    |   0   |   6   |      3       |   4    |   #a#b#a#   |
|    4 |   #    |   0   |   6   |      0       |   1    |      #      |
|    5 |   a    |   0   |  10   |      5       |   6    | #a#b#a#b#a# |
|    6 |   #    |   0   |  10   |      0       |   1    |      #      |
|    7 |   b    |   2   |  12   |      5       |   6    | #b#a#b#a#b# |
|    8 |   #    |   2   |  12   |      0       |   1    |      #      |
|    9 |   a    |   2   |  12   |      3       |   4    |   #b#a#b#   |
|   10 |   #    |   2   |  12   |      0       |   1    |      #      |
|   11 |   b    |   2   |  12   |      1       |   2    |     #b#     |
|   12 |   #    |   2   |  12   |      0       |   1    |      #      |
|   13 |   c    |  12   |  14   |      1       |   2    |     #c#     |
|   14 |   #    |  12   |  14   |      0       |   1    |      #      |
