# 后缀数组

注意：**字符串下标从1开始**

数组的后缀$i$指从第$i$个字母到字符串结束的子串，记做 $\text{Suffix(i)}$

后缀数组主要由两个序列组成：

- `sa`
  - `sa[i]` 表示将所有后缀排序后第`i`小的后缀的编号
- `rank`
  - `rank[i]` 表示后缀`i`的排名

易得 `sa[rank[i]] == rank[sa[i]] == i`

因此需要建立 `sa` 与 `rank` 这两个数组

## 朴素算法

`substring` + `std::sort`，时间复杂度`O(n * n * log(n))`

## 倍增 + `std::sort`

关键问题：如何快速比较字符串大小

思路：规模从小到大，倍增式提升

- 首先对所有长度为$1(=2^0)$的子串排序，得到 $\text{rank}_{1}$数组
- 然后，假设我们已经得到了长度为$w=(2^k)$的子串的顺序$\text{rank}_{w}$
- 利用这个信息计算长度为$2w=(2^{k+1})$的子串顺序$\text{rank}_{2w}$
- 使用双关键字排序：
  - 第一关键字：$\text{rank}_{w}[i]$
  - 第二关键字：$\text{rank}_{w}[i+w]$
  - **注意边界处理$**
- 由此排序可以得到$\text{rank}_{2w}$
- 递推直到倍增结束
  
使用`std::sort`，有$\Theta(n\log^2n)$

## 倍增 + 基数排序

使用基数排序将排序的$\Theta(n\log n)$开销降低至$\Theta(n)$

