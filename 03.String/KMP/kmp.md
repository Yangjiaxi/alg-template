# 前缀函数与KMP

## 前缀函数

KMP的核心就是前缀函数`pi[i]`

性质A：对于一个字符串，如果它的一个前缀同时也是它的后缀，则称这个前缀满足性质A

对于一个字符串`s[0..n-1]`，它的前缀函数也是一个数组`pi[0..n-1]`。其中，`pi[i]`为字符子串`s[0..=i]`中，满足*性质A*的**最长**真前缀的**长度**。

注意：真前缀规定了参与讨论的集合不包括字符串`s`本身

## 线性时间计算前缀函数

首先明确几个要点

- `pi[i]`保存的是**长度**
- `pi[i]`可以从**前缀**和**后缀**两个角度看待
  - `j = pi[i]`
  - `s[0..j-1] == s[i+1-j..i]` 前缀=后缀

初始化：令`pi[0] = 0`

归纳步：对于位置`i (1<=i<n)`，其前面的`pi[k] (0<=k<i)`都已经计算完毕，现在需要充分利用已经计算得到的结果来推算出`pi[i]`

情况1：可以直接扩展 `s[i] == s[pi[i-1]]`

情况2：不能扩展，因为不匹配 `s[i]!=s[pi[i-1]]`，此时我们需要找到使`s[i]`满足前缀条件的最大长度`k`，推导可得`k=pi[j-1]`

## 使用前缀函数计算模式串在文本中的所有出现位置

原始思路：将模式串与文本串接，求一遍前缀函数，对于文本串部分的`pi[i]`，找到`pi[i]>=#pattern`的子串

缺点：空间开销较大`O(#pattern + #text)`

改进：实际上只用到了`O(#pattern)`这么大的空间，所以只用对`pattern`建立前缀函数数组。
