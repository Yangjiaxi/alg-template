# 筛

筛法是一种算法思想。筛是一种用来过滤的工具，它的基本思想是利用之前得到的结果，对未来的运算复杂程度进行化简。

## 筛法求欧拉函数

$$
\varphi(n) = n\prod_{p_i | n}(1 - \frac{1}{p_i})
$$

其中$p_i$为$n$的升序排列的素数因子

将上式展开有

$$
\varphi(n) = n(1 - \frac{1}{p_1})(1 - \frac{1}{p_2})\cdots (1 - \frac{1}{p_s})
$$

观察可得，如果我们可以从小到大求出每个素数，就可以逐渐完成每个合数的欧拉函数值

这里需要以下两个（显而易见的）定理：

1. 素数$p$的欧拉函数为$\varphi(p)=p-1$
2. 互素数乘积的欧拉函数为欧拉函数的乘积

$$
\forall{a, b}:\text{gcd}(a,b)=1\implies \varphi(ab)=\varphi(a)*\varphi(b)
$$

算法流程为

```javascript
01 | phi{n} <- 初始化
02 | phi[1] <- 1
03 | for i in 2->n:
04 |     若phi[i]为初始值，则:
05 |         for j in i -> n (step=i)
06 |             若phi[j]为初始值，则:
07 |                 phi[j] <- j
08 |             phi[j] <- phi[j] / i * (i - 1)
09 |     否则，继续循环
```

对于第4行，若`phi[i]`为初始值，则可说明`i`就是一个素数。

**证明：**

观察对`phi`数组的修改动作，只有`phi[j]`的两处，第六行与第八行。

第六行的`j`与`i`相同，由于循环变量递增，则第六行是`phi[i]`的第一次赋值，这说明前面的`2~i-1`中不存在`i`的因子，即：**i为素数**。配合第八行则置`phi[i]=i-1`，这便得到了素数的欧拉函数值。

在后续的内层`05~08`循环中，若`i`是`j`的最小素数因子，则`phi[j]`被先初始化为`j`（e.g. 6有最小值因子2，则先初始化`phi[6]=6`），否则直接进入第八行（e.g. `i=3, j=6`时，由于`i=2`已经对`phi[6]`修改过，因此直接进入第八行）。第八行进行$\hat{\varphi}'[j]=\hat{\varphi}[j]*\frac{i-1}{i}=\hat{\varphi}[j]*(1-\frac{1}{i})$。

随着`i`的增大，当`i`到达`j`的**最大**素数因子时，`phi[j]`计算完毕。

## 筛法求素数

Eratosthenes 筛法 （埃拉托斯特尼筛法）

### 朴素算法

对于任意$i\in [1, n]$，$i$的倍数一定为素数。

### 改进（Euler筛）

容易看出，上一种算法对一个合数可能进行多次标记

例如，对于$2$和$3$，其都会对$6$产生标记，这些无用功可以通过欧拉函数消除掉。

## 筛法求莫比乌斯函数

同理，每次用一个质因子$p$，去计算（完善）后面数$i$的`mu[i]`

分为三种情况：

1. $i$为质数，则`mu[i]=-1`
2. $i$为$p$的倍数，则$i*p$中包含了$p^2$，则`mu[i*p]=0`
3. $i$不包含$p$，则`mu[i*p]=-mu[i]`
